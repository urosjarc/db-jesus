package com.urosjarc.dbmessiah.impl.oracle

import com.urosjarc.dbmessiah.Schema
import com.urosjarc.dbmessiah.Serializer
import com.urosjarc.dbmessiah.data.Query
import com.urosjarc.dbmessiah.data.TypeSerializer
import com.urosjarc.dbmessiah.domain.Page
import kotlin.reflect.KClass

public open class OracleSerializer(
    schemas: List<OracleSchema> = listOf(),
    globalSerializers: List<TypeSerializer<*>> = listOf(),
    globalInputs: List<KClass<*>> = listOf(),
    globalOutputs: List<KClass<*>> = listOf(),
    globalProcedures: List<KClass<*>> = listOf()
) : Serializer(
    schemas = schemas,
    globalSerializers = globalSerializers,
    globalInputs = globalInputs,
    globalOutputs = globalOutputs,
    globalProcedures = globalProcedures
) {
    override val selectLastId: String? = null

    /**
     * Creates a new database schema if it does not already exist.
     *
     * @param schema The [Schema] object representing the schema to be created.
     * @return A [Query] object representing the SQL query to create the schema.
     */
    override fun createSchema(schema: Schema): Query {
        return Query(sql = "CREATE USER ${schema.name} IDENTIFIED BY ${schema.name}")
    }

    override fun <T : Any> createTable(table: KClass<T>): Query {
        val T = this.mapper.getTableInfo(kclass = table)

        val col = mutableListOf<String>()
        val constraints = mutableListOf<String>()

        //Primary key
        val autoIncrement = if (T.primaryKey.autoInc) " GENERATED BY DEFAULT ON NULL AS IDENTITY" else ""
        col.add("${T.primaryKey.name} ${T.primaryKey.dbType}${autoIncrement}")
        constraints.add("PRIMARY KEY (pk)")

        //Foreign keys
        T.foreignKeys.forEach {
            val notNull = if (it.notNull) " NOT NULL" else ""
            val unique = if (it.unique) " UNIQUE" else ""
            val deleteCascade = if (it.cascadeDelete) " ON DELETE CASCADE" else ""
            val updateCascade = if (it.cascadeUpdate) " ON UPDATE CASCADE" else ""
            col.add("${it.name} ${it.dbType}$notNull$unique")
            constraints.add(
                "FOREIGN KEY (${it.name}) REFERENCES ${it.foreignTable.path}(${it.foreignTable.primaryKey.name})$updateCascade$deleteCascade"
            )
        }

        //Other columns
        T.otherColumns.forEach {
            val notNull = if (it.notNull) " NOT NULL" else ""
            val unique = if (it.unique) " UNIQUE" else ""
            col.add("${it.name} ${it.dbType}$notNull$unique")
        }

        //Connect all column definitions to one string
        val columns = (col + constraints).joinToString(", ")

        //Return created query
        return Query(sql = "CREATE TABLE ${T.path} ($columns)")
    }

    public override fun <T : Any> selectTable(table: KClass<T>, page: Page<T>): Query {
        val T = this.mapper.getTableInfo(kclass = table)
        return Query(sql = "SELECT * FROM ${T.path} ORDER BY ${page.orderBy.name} OFFSET ${page.offset} ROWS FETCH NEXT ${page.limit} ROWS ONLY")
    }

    override fun <T : Any> dropTable(table: KClass<T>, cascade: Boolean): Query {
        val T = this.mapper.getTableInfo(kclass = table)
        val cascadeSql = if (cascade) " CASCADE CONSTRAINTS" else ""
        return Query(sql = "DROP TABLE ${T.path}$cascadeSql")
    }


    public override fun <T : Any> callProcedure(procedure: T): Query {
        val P = this.mapper.getProcedure(obj = procedure)
        var args = P.args.map { "${it.name} => ?" }.joinToString(", ")
        args = if (P.args.isEmpty()) "()" else "($args)"
        return Query(
            sql = "CALL ${P.path}$args",
            *P.queryValues(obj = procedure)
        )
    }

    override fun <T : Any> dropProcedure(procedure: KClass<T>): Query {
        val P = this.mapper.getProcedure(kclass = procedure)
        return Query(sql = "DROP PROCEDURE ${P.path}")
    }

    /**
     * Generates SQL string for calling stored procedure.
     *
     * @param obj The input object representing the stored procedure to be called.
     * @return A [Query] object representing the SQL query.
     * @throws SerializerException if the [Procedure] for the object cannot be found.
     */
    public override fun <T : Any> createProcedure(procedure: KClass<T>, sql: String): Query {
        val P = this.mapper.getProcedure(kclass = procedure)
        var args = P.args.map { "${it.name} ${it.dbType.split("(").first()}" }.joinToString(", ")
        args = if (P.args.isEmpty()) "" else "($args)"
        return Query(
            sql = """
                CREATE OR REPLACE PROCEDURE ${P.path}$args
                AS BEGIN
                    $sql
                END;
            """.trimIndent()
        )
    }

}
