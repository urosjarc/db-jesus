package com.urosjarc.dbmessiah.queries

import com.urosjarc.dbmessiah.Driver
import com.urosjarc.dbmessiah.Serializer
import com.urosjarc.dbmessiah.exceptions.DriverException
import com.urosjarc.dbmessiah.exceptions.QueryException
import com.urosjarc.dbmessiah.extend.ext_isMutable
import com.urosjarc.dbmessiah.extend.ext_isOptional
import com.urosjarc.dbmessiah.impl.derby.DerbySerializer
import com.urosjarc.dbmessiah.impl.h2.H2Serializer

/**
 * Class that provides various row queries for a database table.
 *
 * @param ser The serializer to use for serialization and deserialization of objects.
 * @param driver The database driver to use for executing queries.
 */
public open class RowQueries(
    public val ser: Serializer,
    public val driver: Driver
) {
    /**
     * Retrieves a row from the database table based on the primary key.
     *
     * @param pk The primary key value of the row.
     * @return The retrieved row as an object of type [T], or null if the row does not exist.
     */
    public inline fun <reified T : Any> select(pk: Any): T? {
        val query = this.ser.selectTable(table = T::class, pk = pk)
        return this.driver.query(query = query) {
            this.ser.mapper.decodeOne(resultSet = it, kclass = T::class)
        }.firstOrNull()
    }

    /**
     * Inserts a row into the table. This method have side effect os updating the primary key
     * if its marked as auto-generated.
     *
     * @param row The object representing the row to be inserted.
     * @throws QueryException if user forgotten to define primary key value or if row is to be inserted again.
     * @throws DriverException if driver created unexpected results.
     */
    public open fun <T : Any> insert(row: T) {
        val T = this.ser.mapper.getTableInfo(obj = row)

        //Create SQL select statement (it knows if to insert with the primary key or not)
        val query = this.ser.insertRow(row = row, batch = false)

        if (T.primaryColumn.autoGenerated) {

            if (T.primaryColumn.getValue(row) != null)
                throw QueryException("Row with already defined auto-generated primary key are not allowed to be inserted: $row")

            /**
             * Derby and every other database (not oracle) supports only Statement.RETURN_GENERATED_KEYS
             * H2 don't have option to escape columns that JDBC needs to return so we will use Statement.RETURN_GENERATED_KEYS instead.
             * Oracle and every other database (not derby) supports returning columns by name directly.
             */
            val pk =
                if (this.ser is DerbySerializer || this.ser is H2Serializer)
                    this.driver.insert(query = query, primaryKey = null, onGeneratedKeysFail = this.ser.selectLastId)
                else this.driver.insert(
                    query = query,
                    primaryKey = this.ser.escaped(T.primaryColumn.name),
                    onGeneratedKeysFail = this.ser.selectLastId
                )

            //Set primary key on object
            T.primaryColumn.setValue(obj = row, value = pk)

        } else {

            if (T.primaryColumn.getValue(row) == null)
                throw QueryException("Row with primary key value, which is not auto-generated, and also null, is not allowed to be inserted: $row")

            //If we don't need to retrieve id joust update table
            val count = this.driver.update(query = query)

            /**
             * If number of updates does not match with one. Then user is not aware of some unexpected database
             * behaviour. We need to warn user of this unexpected behaviour as soon as possible before he is going
             * to the production. These are the problems that needs to be resolved as soon as possible.
             */
            if(count != 1)
                throw DriverException("Driver reported unexpected number of updates '$count' for inserting row: $row")
        }
    }

    /**
     * Updates a row in the database table using the provided object.
     *
     * @param row The object representing the row to be updated.
     * @throws QueryException if the row cannot be updated due to an undefined primary key value.
     * @throws DriverException if an unexpected number of updates is returned.
     */
    public fun <T : Any> update(row: T) {
        val T = this.ser.mapper.getTableInfo(obj = row)

        /**
         * The user code that prepares things for updating has some secret flaw that user does not see,
         * that's why he is trying to update row with invalid primary key. It's better to
         * message the user about problems that are needing to be resolved from his side.
         */
        if (T.primaryColumn.getValue(obj = row) == null)
            throw QueryException("Row can't be updated with undefined primary key value: $row")

        //Create SQL update statement
        val query = this.ser.updateRow(row = row)

        //Return number of updates
        val count = this.driver.update(query = query)

        /**
         * If number of updates does not match with one. Then user is not aware of some unexpected database
         * behaviour. We need to warn user of this unexpected behaviour as soon as possible before he is going
         * to the production. These are the problems that needs to be resolved as soon as possible.
         */
        if (count != 1)
            throw DriverException("Driver reported unexpected number of updates '$count' for updating row: $row")
    }

    /**
     * Deletes a row from the database table.
     *
     * @param row The object representing the row to be deleted.
     * @throws QueryException if the row cannot be deleted due to an undefined primary key value.
     * @throws DriverException if an unexpected number of updates is returned.
     */
    public fun <T : Any> delete(row: T) {
        val T = this.ser.mapper.getTableInfo(obj = row)

        /**
         * The user code that prepares things for deleting has some secret flaw that user does not see,
         * that's why he is trying to delete row with invalid primary key. It's better to
         * message the user about problems that are needing to be resolved from his side.
         */
        if (T.primaryColumn.getValue(obj = row) == null)
            throw QueryException("Row can't be deleted with undefined primary key value: $row")

        //Create SQL delete statement
        val query = this.ser.deleteRow(row = row)

        //Update rows and get change count
        val count = this.driver.update(query = query)

        /**
         * If number of updates does not match with one. Then user is not aware of some unexpected database
         * behaviour. We need to warn user of this unexpected behaviour as soon as possible before he is going
         * to the production. These are the problems that needs to be resolved as soon as possible.
         */
        if (count != 1)
            throw DriverException("Driver reported unexpected number of updates '$count' for updating row: $row")

        /**
         * If user code allows we want to reset the primary column to null to make row
         */
        if(T.primaryColumn.kprop.ext_isMutable && T.primaryColumn.kprop.ext_isOptional)
            T.primaryColumn.setValue(row, null)
    }

    /**
     * Inserts multiple rows into the table. This method iterates over the given [rows] and calls [insert] method for each row.
     *
     * @param rows The objects representing the rows to be inserted.
     */
    public fun <T : Any> insert(rows: Iterable<T>): Unit = rows.forEach { this.insert(row = it) }

    /**
     * Updates multiple rows in the database table using the provided objects.
     *
     * @param rows The objects representing the rows to be updated.
     * @throws QueryException if a row cannot be updated due to an undefined primary key value.
     * @throws DriverException if an unexpected number of updates is returned.
     */
    public fun <T : Any> update(rows: Iterable<T>): Unit = rows.forEach { this.update(row = it) }

    /**
     * Deletes a row from the database table.
     *
     * @param row The object representing the row to be deleted.
     * @throws QueryException if the row cannot be deleted due to an undefined primary key value.
     * @throws DriverException if an unexpected number of updates is returned.
     */
    public fun <T : Any> delete(rows: Iterable<T>): Unit = rows.forEach { this.delete(row = it) }
}
