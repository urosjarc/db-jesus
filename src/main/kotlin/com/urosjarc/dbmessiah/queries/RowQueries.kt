package com.urosjarc.dbmessiah.queries

import com.urosjarc.dbmessiah.Driver
import com.urosjarc.dbmessiah.Serializer
import com.urosjarc.dbmessiah.exceptions.DriverException
import com.urosjarc.dbmessiah.exceptions.QueryException
import com.urosjarc.dbmessiah.impl.derby.DerbySerializer
import com.urosjarc.dbmessiah.impl.h2.H2Serializer

/**
 * Class that provides various row queries for a database table.
 *
 * @param ser The serializer to use for serialization and deserialization of objects.
 * @param driver The database driver to use for executing queries.
 */
public open class RowQueries(
    public val ser: Serializer,
    public val driver: Driver
) {
    /**
     * Retrieves a row from the database table based on the primary key.
     *
     * @param pk The primary key value of the row.
     * @return The retrieved row as an object of type [T], or null if the row does not exist.
     */
    public inline fun <reified T : Any> select(pk: Any): T? {
        val query = this.ser.selectTable(table = T::class, pk = pk)
        return this.driver.query(query = query) {
            this.ser.mapper.decodeOne(resultSet = it, kclass = T::class)
        }.firstOrNull()
    }

    /**
     * Inserts a row into the table. This method have side effect os updating the primary key
     * if its marked as auto-generated.
     *
     * @param row The object representing the row to be inserted.
     * @throws QueryException if user forgotten to define primary key value or if row is to be inserted again.
     * @throws DriverException if driver created unexpected results.
     */
    public open fun <T : Any> insert(row: T) {
        val T = this.ser.mapper.getTableInfo(obj = row)

        //Create SQL select statement (it knows if to insert with the primary key or not)
        val query = this.ser.insertRow(row = row, batch = false)

        if (T.primaryColumn.autoGenerated) {

            if (T.primaryColumn.getValue(row) != null)
                throw QueryException("Row with already defined auto-generated primary key can't be inserted again: $row")

            /**
             * Derby and every other database (not oracle) supports only Statement.RETURN_GENERATED_KEYS
             * H2 don't have option to escape columns that JDBC needs to return so we will use Statement.RETURN_GENERATED_KEYS instead.
             * Oracle and every other database (not derby) supports returning columns by name directly.
             */
            val pk =
                if (this.ser is DerbySerializer || this.ser is H2Serializer)
                    this.driver.insert(query = query, primaryKey = null, onGeneratedKeysFail = this.ser.selectLastId)
                else this.driver.insert(
                    query = query,
                    primaryKey = this.ser.escaped(T.primaryColumn.name),
                    onGeneratedKeysFail = this.ser.selectLastId
                )

            //Set primary key on object
            T.primaryColumn.setValue(obj = row, value = pk)

        } else {

            if (T.primaryColumn.getValue(row) == null)
                throw QueryException("Row with primary key value, which is not auto-generated, and also null, is not allowed to be inserted: $row")

            //If we don't need to retrieve id joust update table
            val numUpdates = this.driver.update(query = query)
            if(numUpdates != 1) //Very low chance of this to happend but still...
                throw DriverException("Driver reported unexpected number of updates '$numUpdates' for inserting row: $row")
        }
    }

    /**
     * Updates a row in the table by its primary key.
     *
     * @param row The object representing the row to be updated.
     * @return true if the row was successfully updated, false otherwise.
     */
    public fun <T : Any> update(row: T): Boolean {
        val T = this.ser.mapper.getTableInfo(obj = row)

        /**
         * The user code that prepares things for updating has some secret flaw that user does not see,
         * that's why he is trying to update row with invalid primary key. It's better to
         * message the user about problems that are needing to be resolved from his side.
         */
        if (T.primaryColumn.getValue(obj = row) == null)
            throw QueryException("Row can't be updated with invalid primary key value: $row")

        //Create SQL update statement
        val query = this.ser.updateRow(row = row)

        //Return number of updates
        val count = this.driver.update(query = query)

        //Success if only 1
        if (count == 1) return true
        else if (count == 0) return false
        else throw QueryException("Number of updated rows must be 1 or 0 but number of updated rows was: $count")
    }

    /**
     * Deletes a row from the table. By its primary key.
     *
     * @param row The object representing the row to be deleted.
     * @return true if the row was successfully deleted, false otherwise.
     */
    public fun <T : Any> delete(row: T): Boolean {
        val T = this.ser.mapper.getTableInfo(obj = row)

        /**
         * The user code that prepares things for deleting has some secret flaw that user does not see,
         * that's why he is trying to delete row with invalid primary key. It's better to
         * message the user about problems that are needing to be resolved from his side.
         */
        if (T.primaryColumn.getValue(obj = row) == null)
            throw QueryException("Row can't be deleted with invalid primary key value: $row")

        //Create SQL delete statement
        val query = this.ser.deleteRow(row = row)

        //Update rows and get change count
        val count = this.driver.update(query = query)

        //Success if only 1
        if (count == 0) return false
        else if (count == 1) return true
        else throw QueryException("Number of deleted rows must be 1 or 0 but number of updated rows was: $count")
    }

    /**
     * Inserts a rows into the table with method [insert]. It should not be confused with batch insert!
     * Primary keys will be assigned in the process!
     *
     * If [row] does not exist in the table, its primary key will be initialized with the assigned database value.
     *
     * @param row The object representing the row to be inserted.
     * @return A list of booleans indicating whether each row was successfully inserted or not.
     */
    public fun <T : Any> insert(rows: Iterable<T>): List<Boolean> = rows.map { this.insert(row = it) }

    /**
     * Updates rows in the table by its primary key with method [update]. It should not be confused with batch update!
     *
     * @param rows The objects representing the rows to be updated.
     * @return A list of booleans indicating whether each row was successfully updated or not.
     */
    public fun <T : Any> update(rows: Iterable<T>): List<Boolean> = rows.map { this.update(row = it) }

    /**
     * Deletes rows in the table by its primary key with method [delete]. It should not be confused with batch delete!
     *
     * @param rows The objects representing the rows to be updated.
     * @return A list of booleans indicating whether each row was successfully updated or not.
     */
    public fun <T : Any> delete(rows: Iterable<T>): List<Boolean> = rows.map { this.delete(row = it) }
}
